Object subclass: #MystObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystObject commentStamp: 'PeterFisk 10/12/2017 08:37' prior: 0!MystObject!!MystObject methodsFor: 'displaying' stamp: 'PeterFisk 10/12/2017 08:58'!displayString	"While printString is about to give a detailled information about an object, displayString is a message that should return a short string-based representation to be used by list and related UI frameworks. By default, simply return printString."	"asString should not be implemented in Object, and kept for conversion between strings, symbols, text and characters."	^ self printString! !!MystObject methodsFor: 'comparing' stamp: 'PeterFisk 10/12/2017 08:44'!= anObject	"Answer whether the receiver and the argument represent the same 	object. If = is redefined in any subclass, consider also redefining the 	message hash."	^ self == anObject! !!MystObject methodsFor: 'comparing' stamp: 'PeterFisk 10/12/2017 08:44'!~= anObject	"Answer whether the receiver and the argument do not represent the 	same object."	^ self = anObject == false! !!MystObject methodsFor: 'converting' stamp: 'PeterFisk 10/12/2017 08:56'!asOrderedCollection	"Answer an OrderedCollection with the receiver as its only element."	^ OrderedCollection with: self! !!MystObject methodsFor: 'converting' stamp: 'PeterFisk 10/12/2017 08:57'!asString	"Answer a string that represents the receiver."	^ self printString! !!MystObject methodsFor: 'evaluating' stamp: 'PeterFisk 10/12/2017 08:59'!value	^ self! !!MystObject methodsFor: 'evaluating' stamp: 'PeterFisk 10/12/2017 08:59'!in: aBlock	"Evaluate the given block with the receiver as its argument."	^ aBlock value: self! !!MystObject methodsFor: 'evaluating' stamp: 'PeterFisk 10/12/2017 08:59'!valueWithArguments: aSequenceOfArguments	^ self! !!MystObject methodsFor: 'message performing' stamp: 'PeterFisk 10/17/2017 11:12'!perform: aSymbol with: anObject	"Send the selector, aSymbol, to the receiver with anObject as its argument.	Fail if the number of arguments expected by the selector is not one.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<primitive: 'perform:with:'>	! !!MystObject methodsFor: 'message performing' stamp: 'PeterFisk 10/12/2017 09:07'!perform: selector withEnoughArguments: anArray	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Only use enough arguments for the arity of the selector; supply nils for missing ones."	| numArgs args |	numArgs := selector numArgs.	anArray size == numArgs		ifTrue: [ ^ self perform: selector withArguments: anArray asArray ].	args := Array new: numArgs.	args		replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self perform: selector withArguments: args! !!MystObject methodsFor: 'message performing' stamp: 'PeterFisk 10/17/2017 11:13'!perform: aSymbol with: firstObject with: secondObject with: thirdObject with: fourthObject	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not four.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<primitive: 'perform:with:with:with:with:'>	! !!MystObject methodsFor: 'message performing' stamp: 'PeterFisk 10/17/2017 11:14'!perform: selector withArguments: argArray	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Fail if the number of arguments expected by the selector 	does not match the size of argArray.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<primitive: 'perform:withArguments:'>	! !!MystObject methodsFor: 'message performing' stamp: 'PeterFisk 10/17/2017 11:14'!perform: selector withArguments: argArray inSuperclass: lookupClass	"NOTE:  This is just like perform:withArguments:, except that	the message lookup process begins, not with the receivers's class,	but with the supplied superclass instead.  It will fail if lookupClass	cannot be found among the receiver's superclasses.	Primitive. Essential. See Object documentation whatIsAPrimitive."	<primitive: 'perform:withArguments:inSuperclass:'>	! !!MystObject methodsFor: 'message performing' stamp: 'PeterFisk 10/12/2017 09:05'!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ (self respondsTo: selector)		ifTrue: [ self perform: selector ]		ifFalse: [ otherTarget perform: selector ]! !!MystObject methodsFor: 'message performing' stamp: 'PeterFisk 10/17/2017 11:12'!perform: aSymbol	"Send the unary selector, aSymbol, to the receiver.	Fail if the number of arguments expected by the selector is not zero.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<primitive: 'perform:'>	! !!MystObject methodsFor: 'message performing' stamp: 'PeterFisk 10/17/2017 11:13'!perform: aSymbol with: firstObject with: secondObject	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not two.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<primitive: 'perform:with:with:'>	! !!MystObject methodsFor: 'message performing' stamp: 'PeterFisk 10/17/2017 11:13'!perform: aSymbol with: firstObject with: secondObject with: thirdObject	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not three.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<primitive: 'perform:with:with:with:'>	! !!MystObject methodsFor: 'printing' stamp: 'PeterFisk 10/12/2017 09:18'!storeString	"Answer a String representation of the receiver from which the receiver 	can be reconstructed."	^ String streamContents: [ :s | self storeOn: s ]! !!MystObject methodsFor: 'printing' stamp: 'PeterFisk 10/12/2017 09:17'!longPrintStringLimitedTo: aLimitValue	"Answer a String whose characters are a description of the receiver."	| str |	str := String		streamContents: [ :aStream | self longPrintOn: aStream limitedTo: aLimitValue indent: 0 ].	"Objects without inst vars should return something"	^ str isEmpty		ifTrue: [ self printString , String cr ]		ifFalse: [ str ]! !!MystObject methodsFor: 'printing' stamp: 'PeterFisk 10/12/2017 09:18'!printString	"Answer a String whose characters are a description of the receiver. 	If you want to print without a character limit, use fullPrintString."	^ self printStringLimitedTo: 50000! !!MystObject methodsFor: 'printing' stamp: 'PeterFisk 10/12/2017 09:17'!longPrintString	"Answer a String whose characters are a description of the receiver."	| str |	str := String streamContents: [ :aStream | self longPrintOn: aStream ].	"Objects without inst vars should return something"	^ str isEmpty		ifTrue: [ self printString , String cr ]		ifFalse: [ str ]! !!MystObject methodsFor: 'printing' stamp: 'PeterFisk 10/12/2017 09:16'!isLiteral	"Answer whether the receiver has a literal text form recognized by the 	compiler."	^ false! !!MystObject methodsFor: 'printing' stamp: 'PeterFisk 10/12/2017 09:17'!longPrintOn: aStream	"Append to the argument, aStream, the names and values of all 	of the receiver's instance variables."	self class allInstVarNames		doWithIndex: [ :title :index | 			aStream				nextPutAll: title;				nextPut: $:;				space;				tab;				print: (self instVarAt: index);				cr ]! !!MystObject methodsFor: 'printing' stamp: 'PeterFisk 10/12/2017 09:18'!storeOn: aStream	"Append to the argument aStream a sequence of characters that is an 	expression whose evaluation creates an object similar to the receiver."	aStream nextPut: $(.	self class isVariable		ifTrue: [ aStream				nextPutAll: '(' , self class name , ' basicNew: ';				store: self basicSize;				nextPutAll: ') ' ]		ifFalse: [ aStream nextPutAll: self class name , ' basicNew' ].	1 to: self class instSize do: [ :i | 		aStream			nextPutAll: ' instVarAt: ';			store: i;			nextPutAll: ' put: ';			store: (self instVarAt: i);			nextPut: $; ].	1 to: self basicSize do: [ :i | 		aStream			nextPutAll: ' basicAt: ';			store: i;			nextPutAll: ' put: ';			store: (self basicAt: i);			nextPut: $; ].	aStream nextPutAll: ' yourself)'! !!MystObject methodsFor: 'printing' stamp: 'PeterFisk 10/12/2017 09:16'!fullPrintString	"Answer a String whose characters are a description of the receiver."	^ String streamContents: [ :s | self printOn: s ]! !!MystObject methodsFor: 'printing' stamp: 'PeterFisk 10/12/2017 09:18'!printOn: aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."	| title |	title := self class name.	aStream		nextPutAll:			(title first isVowel				ifTrue: [ 'an ' ]				ifFalse: [ 'a ' ]);		nextPutAll: title! !!MystObject methodsFor: 'printing' stamp: 'PeterFisk 10/12/2017 09:18'!printStringLimitedTo: limit	"Answer a String whose characters are a description of the receiver.	If you want to print without a character limit, use fullPrintString."	| limitedString |	limitedString := String streamContents: [ :s | self printOn: s ] limitedTo: limit.	limitedString size < limit		ifTrue: [ ^ limitedString ].	^ limitedString , '...etc...'! !!MystObject methodsFor: 'printing' stamp: 'PeterFisk 10/12/2017 09:17'!longPrintOn: aStream limitedTo: sizeLimit indent: indent	"Append to the argument, aStream, the names and values of all of the receiver's instance variables.  Limit is the length limit for each inst var."	self class allInstVarNames		doWithIndex: [ :title :index | 			indent timesRepeat: [ aStream tab ].			aStream				nextPutAll: title;				nextPut: $:;				space;				tab;				nextPutAll: ((self instVarAt: index) printStringLimitedTo: (sizeLimit - 3 - title size max: 1));				cr ]! !!MystObject methodsFor: 'class membership' stamp: 'PeterFisk 10/12/2017 08:54'!isKindOf: aClass	"Answer whether the class, aClass, is a superclass or class of the receiver."	self class == aClass		ifTrue: [ ^ true ]		ifFalse: [ ^ self class inheritsFrom: aClass ]! !!MystObject methodsFor: 'class membership' stamp: 'PeterFisk 10/12/2017 08:54'!isMemberOf: aClass	"Answer whether the receiver is an instance of the class, aClass."	^ self class == aClass! !!MystObject methodsFor: 'class membership' stamp: 'PeterFisk 10/12/2017 08:54'!respondsTo: aSymbol	"Answer whether the method dictionary of the receiver's class contains 	aSymbol as a message selector."	^ self class canUnderstand: aSymbol! !!MystObject methodsFor: 'self evaluating' stamp: 'PeterFisk 10/12/2017 09:25'!isSelfEvaluating	^ self isLiteral! !!MystObject methodsFor: 'associating' stamp: 'PeterFisk 10/12/2017 08:53'!-> anObject	"Answer an Association between self and anObject"	"the code of Association>>#key:value: is inline here for speed"	^ Association basicNew key: self value: anObject! !!MystObject methodsFor: 'introspection' stamp: 'PeterFisk 10/12/2017 09:02'!instVarNamed: aString put: aValue	"Store into the value of the instance variable in me of that name.  Slow and unclean, but very useful. "	^ self		instVarAt: (self class instVarIndexFor: aString asString ifAbsent: [ self error: 'no such inst var' ])		put: aValue! !!MystObject methodsFor: 'introspection' stamp: 'PeterFisk 10/17/2017 11:11'!instVarAt: index put: anObject	"Primitive. Store a value into a fixed variable in an object. The numbering of the	 variables corresponds to the named instance variables, followed by the indexed	 instance variables. Fail if the index is not an Integer or is not the index of a fixed	 variable. Essential. See Object documentation whatIsAPrimitive."	<primitive: 'instVarAt:put:'>	! !!MystObject methodsFor: 'introspection' stamp: 'PeterFisk 10/12/2017 09:01'!className	"Answer a string characterizing the receiver's class, for use in list views for example"	^ self class name asString! !!MystObject methodsFor: 'introspection' stamp: 'PeterFisk 10/12/2017 09:02'!instVarNamed: aString	"Return the value of the instance variable in me with that name.  Slow and unclean, but very useful. "	^ self		instVarAt: (self class instVarIndexFor: aString asString ifAbsent: [ self error: 'no such inst var' ])! !!MystObject methodsFor: 'introspection' stamp: 'PeterFisk 10/17/2017 11:11'!instVarAt: index	"Primitive. Answer a fixed variable in an object. The numbering of the variables	 corresponds to the named instance variables, followed by the indexed instance	 variables. Fail if the index is not an Integer or is not the index of a fixed variable.	 Essential. See Object documentation whatIsAPrimitive."	<primitive: 'instVarAt:'>	! !!MystObject methodsFor: 'accessing' stamp: 'PeterFisk 10/17/2017 11:11'!basicSize	"Primitive. Answer the number of indexable variables in the receiver. 	This value is the same as the largest legal subscript. Essential. Do not 	override in any subclass. See Object documentation whatIsAPrimitive."	"The number of indexable fields of fixed-length objects is 0"	<primitive: 'basicSize'>	! !!MystObject methodsFor: 'accessing' stamp: 'PeterFisk 10/12/2017 08:49'!yourself	"Answer self. The message yourself deserves a bit of explanation.	Sending yourself is handy to get the receiver of a message. It is especially useful when using a cascade since all the cascaded messages are send to the receiver. Let us look at an example.		Imagine that you have the following expression		#('hello' 'world') at: 2 put: 'pharo'	and that you would like to get the modified array #('hello' 'pharo') - the receiver of the message at:put:. 		Right now the expression #('hello' 'world') at: 2 put: 'pharo' returns 'pharo' and not the receiver because the message at:put: always returns the second argument.	 	To get the receiver we can simply use a cascade as follows:		#('hello' 'world') at: 2 put: 'pharo'; yourself	and since yourself returns the receiver of the message we will get the modified array.	Stepping back using a cascade and yourself is equivalent to declare a variable, assign the expression and return the variable as follows:	| a |	a := #('hello' 'world') at: 2 put: 'pharo'.	a 	"		^self! !!MystObject methodsFor: 'accessing' stamp: 'PeterFisk 10/17/2017 11:10'!basicAt: index	"Primitive. Assumes receiver is indexable. Answer the value of an 	indexable element in the receiver. Fail if the argument index is not an 	Integer or is out of bounds. Essential. Do not override in a subclass. See 	Object documentation whatIsAPrimitive."	<primitive: 'basicAt:'>	! !!MystObject methodsFor: 'accessing' stamp: 'PeterFisk 10/17/2017 11:10'!at: index put: value	"Primitive. Assumes receiver is indexable. Store the argument value in 	the indexable element of the receiver indicated by index. Fail if the 	index is not an Integer or is out of bounds. Or fail if the value is not of 	the right type for this kind of collection. Answer the value that was 	stored. Essential. See Object documentation whatIsAPrimitive."	<primitive: 'at:put:'>	! !!MystObject methodsFor: 'accessing' stamp: 'PeterFisk 10/17/2017 11:15'!size	"Primitive. Answer the number of indexable variables in the receiver. 	This value is the same as the largest legal subscript. Essential. See Object 	documentation whatIsAPrimitive."	<primitive: 'size'>	! !!MystObject methodsFor: 'accessing' stamp: 'PeterFisk 10/17/2017 11:10'!at: index	"Primitive. Assumes receiver is indexable. Answer the value of an 	indexable element in the receiver. Fail if the argument index is not an 	Integer or is out of bounds. Essential. See Object documentation 	whatIsAPrimitive. Read the class comment for a discussion about that the fact	that the index can be a float."	<primitive: 'at:'>	! !!MystObject methodsFor: 'accessing' stamp: 'PeterFisk 10/17/2017 11:10'!basicAt: index put: value	"Primitive. Assumes receiver is indexable. Store the second argument 	value in the indexable element of the receiver indicated by index. Fail 	if the index is not an Integer or is out of bounds. Or fail if the value is 	not of the right type for this kind of collection. Answer the value that 	was stored. Essential. Do not override in a subclass. See Object 	documentation whatIsAPrimitive."	<primitive: 'basicAt:put:'>	! !!MystObject methodsFor: 'initialization' stamp: 'PeterFisk 10/23/2017 15:05'!initialize	^ nil! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MystObject class	instanceVariableNames: ''!!MystObject class methodsFor: 'instance creation' stamp: 'PeterFisk 10/14/2017 10:13'!newFrom: aSimilarObject	"Create an object that has similar contents to aSimilarObject. If the classes have any instance variables with the same names, copy them across. If this is bad for a class, override this method."	^ (self isVariable		ifTrue: [self basicNew: aSimilarObject basicSize]		ifFalse: [self basicNew]) copySameFrom: aSimilarObject! !!MystObject class methodsFor: 'instance creation' stamp: 'PeterFisk 10/14/2017 10:13'!readFrom: textStringOrStream	"Create an object based on the contents of textStringOrStream."	| object |	object := self class compiler evaluate: textStringOrStream.	(object isKindOf: self) ifFalse: [self error: self name, ' expected'].	^object! !!MystObject class methodsFor: 'instance creation' stamp: 'PeterFisk 10/23/2017 14:50'!new	| object |	object := self basicNew.	object initialize.	^ object! !MystObject subclass: #MystBehavior	instanceVariableNames: 'superclass methodDict'	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystBehavior commentStamp: 'PeterFisk 10/12/2017 08:38' prior: 0!MystBehavior!!MystBehavior methodsFor: 'accessing' stamp: 'PeterFisk 10/12/2017 09:45'!methodDict	^ methodDict! !!MystBehavior methodsFor: 'accessing' stamp: 'PeterFisk 10/12/2017 09:45'!superclass: anObject	superclass := anObject! !!MystBehavior methodsFor: 'accessing' stamp: 'PeterFisk 10/12/2017 09:45'!superclass	^ superclass! !!MystBehavior methodsFor: 'accessing' stamp: 'PeterFisk 10/12/2017 09:45'!methodDict: anObject	methodDict := anObject! !MystObject subclass: #MystBoolean	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystBoolean commentStamp: 'PeterFisk 10/12/2017 09:21' prior: 0!MystBoolean!!MystBoolean methodsFor: 'logical operations' stamp: 'PeterFisk 10/12/2017 09:26'!==> aBlock	"The material conditional, also known as the material implication or truth functional conditional.	Correspond to not ... or ... and does not correspond to the English if...then... construction.			 known as:			b if a 			a implies b			if a then b			b is a consequence of a			a therefore b (but note: 'it is raining therefore it is cloudy' is implication; 'it is autumn therefore the leaves are falling' is equivalence).			Here is the truth table for material implication:		   p   |   q   |   p ==> q	-------|-------|-------------	   T   |   T   |      T	   T   |   F   |      F	   F   |   T   |      T	   F   |   F   |      T	"	^ self not or: [ aBlock value ]! !!MystBoolean methodsFor: 'logical operations' stamp: 'PeterFisk 10/12/2017 09:27'!not	"Negation. Answer true if the receiver is false, answer false if the 	receiver is true."	self subclassResponsibility! !!MystBoolean methodsFor: 'logical operations' stamp: 'PeterFisk 10/12/2017 09:27'!eqv: aBoolean	"Answer true if the receiver is equivalent to aBoolean."	^ self == aBoolean! !!MystBoolean methodsFor: 'logical operations' stamp: 'PeterFisk 10/12/2017 09:26'!| aBoolean	"Evaluating disjunction (OR). Evaluate the argument. Then answer true 	if either the receiver or the argument is true."	self subclassResponsibility! !!MystBoolean methodsFor: 'logical operations' stamp: 'PeterFisk 10/12/2017 09:26'!& aBoolean	"Evaluating conjunction. Evaluate the argument. Then answer true if 	both the receiver and the argument are true."	self subclassResponsibility! !!MystBoolean methodsFor: 'controlling' stamp: 'PeterFisk 10/12/2017 09:23'!or: alternativeBlock	"Nonevaluating disjunction. If the receiver is false, answer the value of 	the argument, alternativeBlock; otherwise answer true without 	evaluating the argument."	self subclassResponsibility! !!MystBoolean methodsFor: 'controlling' stamp: 'PeterFisk 10/12/2017 09:23'!xor: alternativeBlock	"Nonevaluating conjunction. If the receiver is true, answer the opposite of the 	the argument, alternativeBlock; otherwise answer the value of the alternativeBlock."	self subclassResponsibility! !!MystBoolean methodsFor: 'controlling' stamp: 'PeterFisk 10/12/2017 09:22'!and: alternativeBlock	"Nonevaluating conjunction. If the receiver is true, answer the value of 	the argument, alternativeBlock; otherwise answer false without 	evaluating the argument."	self subclassResponsibility! !!MystBoolean methodsFor: 'controlling' stamp: 'PeterFisk 10/12/2017 09:23'!ifTrue: alternativeBlock	"If the receiver is false (i.e., the condition is false), then the value is the 	false alternative, which is nil. Otherwise answer the result of evaluating 	the argument, alternativeBlock. Create an error notification if the 	receiver is nonBoolean. Execution does not actually reach here because 	the expression is compiled in-line."	self subclassResponsibility! !!MystBoolean methodsFor: 'controlling' stamp: 'PeterFisk 10/12/2017 09:22'!ifFalse: alternativeBlock	"If the receiver is true (i.e., the condition is true), then the value is the 	true alternative, which is nil. Otherwise answer the result of evaluating 	the argument, alternativeBlock. Create an error notification if the 	receiver is nonBoolean. Execution does not actually reach here because 	the expression is compiled in-line."	self subclassResponsibility! !!MystBoolean methodsFor: 'controlling' stamp: 'PeterFisk 10/12/2017 09:23'!ifFalse: falseAlternativeBlock ifTrue: trueAlternativeBlock	"Same as ifTrue:ifFalse:."	self subclassResponsibility! !!MystBoolean methodsFor: 'controlling' stamp: 'PeterFisk 10/12/2017 09:23'!ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock	"If the receiver is true (i.e., the condition is true), then answer the value 	of the argument trueAlternativeBlock. If the receiver is false, answer the 	result of evaluating the argument falseAlternativeBlock. If the receiver 	is a nonBoolean then create an error notification. Execution does not 	actually reach here because the expression is compiled in-line."	self subclassResponsibility! !!MystBoolean methodsFor: 'printing' stamp: 'PeterFisk 10/12/2017 09:27'!isLiteral	^ true! !!MystBoolean methodsFor: 'printing' stamp: 'PeterFisk 10/12/2017 09:28'!storeOn: aStream	"Refer to the comment in Object|storeOn:."	self printOn: aStream! !!MystBoolean methodsFor: 'self evaluating' stamp: 'PeterFisk 10/12/2017 09:28'!isSelfEvaluating	^ true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MystBoolean class	instanceVariableNames: ''!!MystBoolean class methodsFor: 'instance creation' stamp: 'PeterFisk 10/14/2017 10:14'!new	self error: 'You may not create any more Booleans - this is two-valued logic'! !MystBehavior subclass: #MystClass	instanceVariableNames: 'subclasses name localSelectors'	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystClass commentStamp: 'PeterFisk 10/12/2017 08:38' prior: 0!MystClass!!MystClass methodsFor: 'accessing' stamp: 'PeterFisk 10/12/2017 09:46'!subclasses: anObject	subclasses := anObject! !!MystClass methodsFor: 'accessing' stamp: 'PeterFisk 10/12/2017 09:47'!name	^ name! !!MystClass methodsFor: 'accessing' stamp: 'PeterFisk 10/12/2017 09:46'!name: anObject	name := anObject! !!MystClass methodsFor: 'accessing' stamp: 'PeterFisk 10/12/2017 09:46'!localSelectors: anObject	localSelectors := anObject! !!MystClass methodsFor: 'accessing' stamp: 'PeterFisk 10/12/2017 09:46'!subclasses	^ subclasses! !!MystClass methodsFor: 'accessing' stamp: 'PeterFisk 10/12/2017 09:46'!localSelectors	^ localSelectors! !MystObject subclass: #MystCollection	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystCollection commentStamp: 'PeterFisk 10/14/2017 10:19' prior: 0!MystCollection!!MystCollection methodsFor: 'adding' stamp: 'PeterFisk 10/14/2017 10:35'!add: newObject 	"Include newObject as one of the receiver's elements. Answer newObject. 	ArrayedCollections cannot respond to this message."	self subclassResponsibility! !!MystCollection methodsFor: 'adding' stamp: 'PeterFisk 10/14/2017 10:37'!asOrderedCollection	"Answer an OrderedCollection whose elements are the elements of the	receiver. The order in which elements are added depends on the order	in which the receiver enumerates its elements. In the case of unordered	collections, the ordering is not necessarily the same for multiple 	requests for the conversion."	^ self as: OrderedCollection! !!MystCollection methodsFor: 'adding' stamp: 'PeterFisk 10/14/2017 10:36'!addAll: aCollection	"Include all the elements of aCollection as the receiver's elements. Answer 	aCollection. Actually, any object responding to #do: can be used as argument."	aCollection do: [ :each | self add: each ].	^ aCollection! !!MystCollection methodsFor: 'adding' stamp: 'PeterFisk 10/14/2017 10:36'!asArray	"Answer an Array whose elements are the elements of the receiver.	Implementation note: Cannot use ''Array withAll: self'' as that only	works for SequenceableCollections which support the replacement 	primitive."	| newArray index |	newArray := Array new: self size.	index := 0.	self do: [ :each | newArray at: (index := index + 1) put: each ].	^ newArray! !!MystCollection methodsFor: 'adding' stamp: 'PeterFisk 10/14/2017 10:36'!addIfNotPresent: anObject	"Include anObject as one of the receiver's elements, but only if there	is no such element already. Anwser anObject."	(self includes: anObject)		ifFalse: [ self add: anObject ].	^ anObject! !!MystCollection methodsFor: 'removing' stamp: 'PeterFisk 10/14/2017 10:40'!remove: oldObject ifAbsent: anExceptionBlock	"Remove oldObject from the receiver's elements. If several of the 	elements are equal to oldObject, only one is removed. If no element is 	equal to oldObject, answer the result of evaluating anExceptionBlock. 	Otherwise, answer the argument, oldObject. ArrayedCollections cannot 	respond to this message."	self subclassResponsibility! !!MystCollection methodsFor: 'removing' stamp: 'PeterFisk 10/14/2017 10:40'!remove: oldObject	"Remove oldObject from the receiver's elements. Answer oldObject 	unless no element is equal to oldObject, in which case, raise an error.	ArrayedCollections cannot respond to this message."	^ self remove: oldObject ifAbsent: [ self errorNotFound: oldObject ]! !!MystCollection methodsFor: 'removing' stamp: 'PeterFisk 10/14/2017 10:40'!removeAll	"Remove each element from the receiver and leave it empty.	ArrayedCollections cannot respond to this message.	There are two good reasons why a subclass should override this message:	1) the subclass does not support being modified while being iterated	2) the subclass provides a much faster way than iterating through each element"	self do: [ :each | self remove: each ]! !!MystCollection methodsFor: 'removing' stamp: 'PeterFisk 10/14/2017 10:41'!removeAll: aCollection	"Remove each element of aCollection from the receiver. If successful for 	each, answer aCollection. Otherwise create an error notification.	ArrayedCollections cannot respond to this message."	aCollection == self		ifTrue: [ ^ self removeAll ].	aCollection do: [ :each | self remove: each ].	^ aCollection! !!MystCollection methodsFor: 'enumerating' stamp: 'PeterFisk 10/14/2017 10:38'!do: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument."	self subclassResponsibility! !!MystCollection methodsFor: 'enumerating' stamp: 'PeterFisk 10/14/2017 10:39'!select: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect into a new collection like the receiver, only those elements for 	which aBlock evaluates to true. Answer the new collection."	| newCollection |	newCollection := self copyEmpty.	self		do: [ :each | 			(aBlock value: each)				ifTrue: [ newCollection add: each ] ].	^ newCollection! !!MystCollection methodsFor: 'enumerating' stamp: 'PeterFisk 10/14/2017 10:39'!reject: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect into a new collection like the receiver only those elements for 	which aBlock evaluates to false. Answer the new collection."	^ self select: [ :element | (aBlock value: element) == false ]! !!MystCollection methodsFor: 'enumerating' stamp: 'PeterFisk 10/14/2017 10:38'!collect: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."	| newCollection |	newCollection := self species new.	self do: [ :each | newCollection add: (aBlock value: each) ].	^ newCollection! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MystCollection class	instanceVariableNames: ''!!MystCollection class methodsFor: 'instance creation' stamp: 'PeterFisk 10/14/2017 10:33'!empty	^ self new! !!MystCollection class methodsFor: 'instance creation' stamp: 'PeterFisk 10/14/2017 10:33'!with: firstObject with: secondObject with: thirdObject	"Answer an instance of me containing the three arguments as elements."	^ self new		add: firstObject;		add: secondObject;		add: thirdObject;		yourself! !!MystCollection class methodsFor: 'instance creation' stamp: 'PeterFisk 10/14/2017 10:34'!with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject	"Answer an instance of me, containing the five arguments as the elements."	^ self new		add: firstObject;		add: secondObject;		add: thirdObject;		add: fourthObject;		add: fifthObject;		yourself! !!MystCollection class methodsFor: 'instance creation' stamp: 'PeterFisk 10/14/2017 10:33'!with: anObject	"Answer an instance of me containing anObject."	^ self empty		add: anObject;		yourself! !!MystCollection class methodsFor: 'instance creation' stamp: 'PeterFisk 10/14/2017 10:33'!with: firstObject with: secondObject with: thirdObject with: fourthObject	"Answer an instance of me, containing the four arguments as the elements."	^ self new		add: firstObject;		add: secondObject;		add: thirdObject;		add: fourthObject;		yourself! !!MystCollection class methodsFor: 'instance creation' stamp: 'PeterFisk 10/14/2017 10:33'!with: firstObject with: secondObject	"Answer an instance of me containing the two arguments as elements."	^ self new		add: firstObject;		add: secondObject;		yourself! !!MystCollection class methodsFor: 'instance creation' stamp: 'PeterFisk 10/14/2017 10:34'!with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject with: sixthObject	"Answer an instance of me, containing the six arguments as the elements."	^ self new		add: firstObject;		add: secondObject;		add: thirdObject;		add: fourthObject;		add: fifthObject;		add: sixthObject;		yourself! !!MystCollection class methodsFor: 'instance creation' stamp: 'PeterFisk 10/14/2017 10:34'!withAll: aCollection	"Create a new collection containing all the elements from aCollection."	^ (self new: aCollection size)		addAll: aCollection;		yourself! !MystBoolean subclass: #MystFalse	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystFalse commentStamp: 'PeterFisk 10/12/2017 09:21' prior: 0!MystFalse!!MystFalse methodsFor: 'printing' stamp: 'PeterFisk 10/12/2017 09:33'!printOn: aStream	aStream nextPutAll: 'false'! !!MystFalse methodsFor: 'controlling' stamp: 'PeterFisk 10/12/2017 09:31'!or: alternativeBlock	"Nonevaluating disjunction -- answer value of alternativeBlock."	^ alternativeBlock value! !!MystFalse methodsFor: 'controlling' stamp: 'PeterFisk 10/12/2017 09:30'!and: alternativeBlock	"Nonevaluating conjunction -- answer with false since the receiver is false."	^ self! !!MystFalse methodsFor: 'controlling' stamp: 'PeterFisk 10/12/2017 09:30'!ifTrue: alternativeBlock	"Since the condition is false, answer the value of the false alternative, 	which is nil. Execution does not actually reach here because the	expression is compiled in-line."	^ nil! !!MystFalse methodsFor: 'controlling' stamp: 'PeterFisk 10/12/2017 09:30'!ifFalse: alternativeBlock	"Answer the value of alternativeBlock. Execution does not actually	reach here because the expression is compiled in-line."	^ alternativeBlock value! !!MystFalse methodsFor: 'controlling' stamp: 'PeterFisk 10/12/2017 09:30'!ifFalse: falseAlternativeBlock ifTrue: trueAlternativeBlock	"Answer the value of falseAlternativeBlock. Execution does not	actually reach here because the expression is compiled in-line."	^ falseAlternativeBlock value! !!MystFalse methodsFor: 'controlling' stamp: 'PeterFisk 10/12/2017 09:31'!ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock	"Answer the value of falseAlternativeBlock. Execution does not	actually reach here because the expression is compiled in-line."	^ falseAlternativeBlock value! !!MystFalse methodsFor: 'logical operations' stamp: 'PeterFisk 10/12/2017 09:32'!| aBoolean	"Evaluating disjunction (OR) -- answer with the argument, aBoolean."	^ aBoolean! !!MystFalse methodsFor: 'logical operations' stamp: 'PeterFisk 10/12/2017 09:32'!not	"Negation -- answer true since the receiver is false."	^ true! !!MystFalse methodsFor: 'logical operations' stamp: 'PeterFisk 10/12/2017 09:31'!& aBoolean	"Evaluating conjunction -- answer false since receiver is false."	^ self! !!MystFalse methodsFor: 'logical operations' stamp: 'PeterFisk 10/12/2017 09:32'!xor: aBoolean	^ aBoolean value! !MystCollection subclass: #MystHashedCollection	instanceVariableNames: 'tally array'	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystHashedCollection commentStamp: 'PeterFisk 10/14/2017 13:13' prior: 0!MystHashedCollection!MystHashedCollection subclass: #MystDictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystDictionary commentStamp: 'PeterFisk 10/14/2017 13:15' prior: 0!MystDictionary!MystObject subclass: #MystMagnitude	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystMagnitude commentStamp: 'PeterFisk 10/16/2017 14:29' prior: 0!MystNumber!MystBehavior subclass: #MystMetaClass	instanceVariableNames: 'thisClass localSelectors'	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystMetaClass commentStamp: 'PeterFisk 10/12/2017 08:39' prior: 0!MystMetaClass!!MystMetaClass methodsFor: 'accessing' stamp: 'PeterFisk 10/12/2017 09:47'!localSelectors	^ localSelectors! !!MystMetaClass methodsFor: 'accessing' stamp: 'PeterFisk 10/12/2017 09:47'!localSelectors: anObject	localSelectors := anObject! !!MystMetaClass methodsFor: 'accessing' stamp: 'PeterFisk 10/12/2017 09:47'!thisClass	^ thisClass! !!MystMetaClass methodsFor: 'accessing' stamp: 'PeterFisk 10/12/2017 09:47'!thisClass: anObject	thisClass := anObject! !MystMagnitude subclass: #MystNumber	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystNumber commentStamp: 'PeterFisk 10/16/2017 14:30' prior: 0!MystNumber!MystNumber subclass: #MystFloat	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystFloat commentStamp: 'PeterFisk 10/16/2017 14:31' prior: 0!MystFloat!MystNumber subclass: #MystInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystInteger commentStamp: 'PeterFisk 10/16/2017 14:31' prior: 0!MystInteger!MystCollection subclass: #MystSequenceableCollection	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystSequenceableCollection commentStamp: 'PeterFisk 10/14/2017 13:14' prior: 0!MystSequenceableCollection!MystSequenceableCollection subclass: #MystArrayedCollection	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystArrayedCollection commentStamp: 'PeterFisk 10/14/2017 13:17' prior: 0!MystArrayedCollection!MystArrayedCollection subclass: #MystArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystArray commentStamp: 'PeterFisk 10/14/2017 13:19' prior: 0!MystArray!MystSequenceableCollection subclass: #MystOrderedCollection	instanceVariableNames: 'array firstIndex lastIndex'	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystOrderedCollection commentStamp: 'PeterFisk 10/14/2017 13:18' prior: 0!MystOrderedCollection!MystObject subclass: #MystServer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystServer commentStamp: 'PeterFisk 10/25/2017 14:24' prior: 0!MystServer!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MystServer class	instanceVariableNames: ''!!MystServer class methodsFor: 'services' stamp: 'PeterFisk 10/25/2017 14:48'!urlFetch: aUrlString	<primitive: 'urlFetch'>	! !!MystServer class methodsFor: 'services' stamp: 'PeterFisk 10/25/2017 14:51'!test	^ self urlFetch: 'https://www.google.com/humans.txt'! !MystArrayedCollection subclass: #MystString	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystString commentStamp: 'PeterFisk 10/16/2017 15:24' prior: 0!MystString!MystBoolean subclass: #MystTrue	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystTrue commentStamp: 'PeterFisk 10/12/2017 09:22' prior: 0!MystTrue!!MystTrue methodsFor: 'printing' stamp: 'PeterFisk 10/12/2017 09:36'!printOn: aStream	aStream nextPutAll: 'true'! !!MystTrue methodsFor: 'logical operations' stamp: 'PeterFisk 10/12/2017 09:35'!| aBoolean	"Evaluating disjunction (OR) -- answer true since the receiver is true."	^ self! !!MystTrue methodsFor: 'logical operations' stamp: 'PeterFisk 10/12/2017 09:35'!not	"Negation--answer false since the receiver is true."	^ false! !!MystTrue methodsFor: 'logical operations' stamp: 'PeterFisk 10/12/2017 09:35'!& aBoolean	"Evaluating conjunction -- answer aBoolean since receiver is true."	^ aBoolean! !!MystTrue methodsFor: 'logical operations' stamp: 'PeterFisk 10/12/2017 09:36'!xor: aBoolean	^ aBoolean value not! !!MystTrue methodsFor: 'controlling' stamp: 'PeterFisk 10/12/2017 09:35'!or: alternativeBlock	"Nonevaluating disjunction -- answer true since the receiver is true."	^ self! !!MystTrue methodsFor: 'controlling' stamp: 'PeterFisk 10/12/2017 09:34'!and: alternativeBlock	"Nonevaluating conjunction -- answer the value of alternativeBlock since	the receiver is true."	^ alternativeBlock value! !!MystTrue methodsFor: 'controlling' stamp: 'PeterFisk 10/12/2017 09:34'!ifTrue: alternativeBlock	"Answer the value of alternativeBlock. Execution does not actually 	reach here because the expression is compiled in-line."	^ alternativeBlock value! !!MystTrue methodsFor: 'controlling' stamp: 'PeterFisk 10/12/2017 09:34'!ifFalse: alternativeBlock	"Since the condition is true, the value is the true alternative, which is nil. 	Execution does not actually reach here because the expression is compiled 	in-line."	^ nil! !!MystTrue methodsFor: 'controlling' stamp: 'PeterFisk 10/12/2017 09:34'!ifFalse: falseAlternativeBlock ifTrue: trueAlternativeBlock	"Answer the value of trueAlternativeBlock. Execution does not 	actually reach here because the expression is compiled in-line."	^ trueAlternativeBlock value! !!MystTrue methodsFor: 'controlling' stamp: 'PeterFisk 10/12/2017 09:34'!ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock	"Answer with the value of trueAlternativeBlock. Execution does not 	actually reach here because the expression is compiled in-line."	^ trueAlternativeBlock value! !MystObject subclass: #MystUndefinedObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystUndefinedObject commentStamp: 'PeterFisk 10/12/2017 09:13' prior: 0!MystUndefinedObject!!MystUndefinedObject methodsFor: 'printing' stamp: 'PeterFisk 10/12/2017 09:19'!printOn: aStream	"Refer to the comment in Object|printOn:."	aStream nextPutAll: 'nil'! !!MystUndefinedObject methodsFor: 'printing' stamp: 'PeterFisk 10/12/2017 09:19'!storeOn: aStream	"Refer to the comment in Object|storeOn:."	aStream nextPutAll: 'nil'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MystUndefinedObject class	instanceVariableNames: ''!!MystUndefinedObject class methodsFor: 'instance creation' stamp: 'PeterFisk 10/14/2017 10:15'!new	self error: 'You may not create any more undefined objects--use nil'! !!MystUndefinedObject class methodsFor: 'accessing' stamp: 'PeterFisk 10/14/2017 10:15'!allInstances	"It is well known there is a single instance"	^ Array with: nil! !!MystUndefinedObject class methodsFor: 'accessing' stamp: 'PeterFisk 10/14/2017 10:15'!allInstancesDo: aBlock	"It is well known there is a single instance"	aBlock value: nil! !MystObject subclass: #MystUx	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystUx commentStamp: 'PeterFisk 10/17/2017 10:28' prior: 0!MystUx!!MystUx methodsFor: 'for testing' stamp: 'PeterFisk 10/26/2017 09:36'!test	^ self testMethod! !!MystUx methodsFor: 'for testing' stamp: 'PeterFisk 10/26/2017 09:34'!testMethod	^ 'MystUx testMethod'! !MystUx subclass: #MystProxy	instanceVariableNames: 'id isCreated properties proxyId'	classVariableNames: 'ProxyCount'	poolDictionaries: ''	category: 'RailsXMyst'!!MystProxy commentStamp: 'PeterFisk 10/17/2017 10:30' prior: 0!MystProxy!!MystProxy methodsFor: 'proxy' stamp: 'PeterFisk 10/23/2017 15:43'!defaultProxyClass	^ 'qx.ui.core.Widget'! !!MystProxy methodsFor: 'proxy' stamp: 'PeterFisk 10/25/2017 13:01'!nextProxyId	<primitive: 'nextProxyId'>	! !!MystProxy methodsFor: 'proxy' stamp: 'PeterFisk 10/23/2017 17:13'!sendMethod: aMethod args: args	self proxySend: self proxyId with: { aMethod. args }! !!MystProxy methodsFor: 'proxy' stamp: 'PeterFisk 10/23/2017 16:07'!proxyCreate: aProxyId class: aString	<primitive: 'create'>! !!MystProxy methodsFor: 'proxy' stamp: 'PeterFisk 10/23/2017 17:13'!proxySend: aProxyId with: anArray	<primitive: 'send'>	! !!MystProxy methodsFor: 'proxy' stamp: 'PeterFisk 10/25/2017 09:37'!sendMethod: aMethod	self proxySend: self proxyId with: {aMethod}! !!MystProxy methodsFor: 'proxy' stamp: 'PeterFisk 10/25/2017 13:08'!create	self proxyId: self nextProxyId.	self proxyCreate: self proxyId class: self defaultProxyClass! !!MystProxy methodsFor: 'accessing' stamp: 'PeterFisk 10/23/2017 14:42'!proxyId	^ proxyId! !!MystProxy methodsFor: 'accessing' stamp: 'PeterFisk 10/23/2017 14:42'!proxyId: anObject	proxyId := anObject! !!MystProxy methodsFor: 'for testing' stamp: 'PeterFisk 10/26/2017 09:36'!test	^ self testMethod! !!MystProxy methodsFor: 'for testing' stamp: 'PeterFisk 10/26/2017 09:35'!testMethod	^ 'MystProxy testMethod'! !!MystProxy methodsFor: 'initialization' stamp: 'PeterFisk 10/25/2017 11:42'!initialize	self create 	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MystProxy class	instanceVariableNames: ''!!MystProxy class methodsFor: 'creation' stamp: 'PeterFisk 10/24/2017 16:40'!proxyId: anInteger	| proxy |	proxy := self basicNew.	proxy proxyId: anInteger.	^ proxy! !MystProxy subclass: #MystDecorator	instanceVariableNames: 'backgroundColor'	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystDecorator commentStamp: 'PeterFisk 10/17/2017 10:32' prior: 0!MystDecorator!MystProxy subclass: #MystLayout	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystLayout commentStamp: 'PeterFisk 10/17/2017 10:34' prior: 0!MystLayout!MystLayout subclass: #MystDockLayout	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystDockLayout commentStamp: 'PeterFisk 10/17/2017 10:35' prior: 0!MystDockLayout!MystLayout subclass: #MystHBoxLayout	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystHBoxLayout commentStamp: 'PeterFisk 10/17/2017 10:36' prior: 0!MystHBoxLayout!MystDecorator subclass: #MystNavPanelDecorator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystNavPanelDecorator commentStamp: 'PeterFisk 10/17/2017 10:32' prior: 0!MystNavPanelDecorator!MystDecorator subclass: #MystTitleBarDecorator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystTitleBarDecorator commentStamp: 'PeterFisk 10/17/2017 10:33' prior: 0!MystTitleBarDecorator!MystLayout subclass: #MystVBoxLayout	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystVBoxLayout commentStamp: 'PeterFisk 10/17/2017 10:36' prior: 0!MystVBoxLayout!MystProxy subclass: #MystWidget	instanceVariableNames: 'addedIdSet layoutParms handlers'	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystWidget commentStamp: 'PeterFisk 10/17/2017 10:37' prior: 0!MystWidget!MystWidget subclass: #MystAtom	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystAtom commentStamp: 'PeterFisk 10/17/2017 10:38' prior: 0!MystAtom!MystAtom subclass: #MystButton	instanceVariableNames: 'config'	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystButton commentStamp: 'PeterFisk 10/17/2017 10:39' prior: 0!MystButton!MystWidget subclass: #MystContainer	instanceVariableNames: 'addedChildren children layout'	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystContainer commentStamp: 'PeterFisk 10/17/2017 10:40' prior: 0!MystContainer!MystContainer subclass: #MystComposite	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystComposite commentStamp: 'PeterFisk 10/17/2017 10:41' prior: 0!MystComposite!MystWidget subclass: #MystEmbedHtml	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystEmbedHtml commentStamp: 'PeterFisk 10/17/2017 10:49' prior: 0!MystEmbedHtml!MystWidget subclass: #MystFont	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystFont commentStamp: 'PeterFisk 10/17/2017 10:50' prior: 0!MystFont!MystWidget subclass: #MystForm	instanceVariableNames: 'fields'	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystForm commentStamp: 'PeterFisk 10/17/2017 10:51' prior: 0!MystForm!MystComposite subclass: #MystHBoxContainer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystHBoxContainer commentStamp: 'PeterFisk 10/17/2017 10:41' prior: 0!MystHBoxContainer!MystHBoxContainer subclass: #MystButtonBar	instanceVariableNames: 'buttons'	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystButtonBar commentStamp: 'PeterFisk 10/17/2017 10:42' prior: 0!MystButtonBar!MystWidget subclass: #MystLabel	instanceVariableNames: 'value'	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystLabel commentStamp: 'PeterFisk 10/17/2017 10:52' prior: 0!MystLabel!MystEmbedHtml subclass: #MystMessageItem	instanceVariableNames: 'body title'	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystMessageItem commentStamp: 'PeterFisk 10/17/2017 10:50' prior: 0!MystMessageItem!MystComposite subclass: #MystPanelWithButtonBar	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystPanelWithButtonBar commentStamp: 'PeterFisk 10/17/2017 10:43' prior: 0!MystPanelWithButtonBar!MystWidget subclass: #MystScroll	instanceVariableNames: 'contentWidget'	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystScroll commentStamp: 'PeterFisk 10/17/2017 10:52' prior: 0!MystScroll!MystScroll subclass: #MystMessageList	instanceVariableNames: 'vbox'	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystMessageList commentStamp: 'PeterFisk 10/17/2017 10:53' prior: 0!MystMessageList!MystContainer subclass: #MystSplitPane	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystSplitPane commentStamp: 'PeterFisk 10/17/2017 10:46' prior: 0!MystSplitPane!MystComposite subclass: #MystTabPage	instanceVariableNames: 'buttons label'	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystTabPage commentStamp: 'PeterFisk 10/17/2017 10:44' prior: 0!MystTabPage!MystWidget subclass: #MystTabView	instanceVariableNames: 'addedChildren children'	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystTabView commentStamp: 'PeterFisk 10/17/2017 10:53' prior: 0!MystTabView!MystWidget subclass: #MystTable	instanceVariableNames: 'columns'	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystTable commentStamp: 'PeterFisk 10/17/2017 10:54' prior: 0!MystTable!MystWidget subclass: #MystTextArea	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystTextArea commentStamp: 'PeterFisk 10/17/2017 10:55' prior: 0!MystTextArea!!MystTextArea methodsFor: 'proxy' stamp: 'PeterFisk 10/24/2017 10:02'!defaultProxyClass	^ 'qx.ui.form.TextArea'! !MystHBoxContainer subclass: #MystTitleBar	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystTitleBar commentStamp: 'PeterFisk 10/17/2017 10:43' prior: 0!MystTitleBar!MystComposite subclass: #MystVBoxContainer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystVBoxContainer commentStamp: 'PeterFisk 10/17/2017 10:45' prior: 0!MystVBoxContainer!MystVBoxContainer subclass: #MystNavPanel	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystNavPanel commentStamp: 'PeterFisk 10/17/2017 10:45' prior: 0!MystNavPanel!MystContainer subclass: #MystWindow	instanceVariableNames: 'autoShow centered location'	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystWindow commentStamp: 'PeterFisk 10/17/2017 10:47' prior: 0!MystWindow!!MystWindow methodsFor: 'proxy' stamp: 'PeterFisk 10/25/2017 11:39'!caption: aString	self sendMethod: 'setCaption' args: {aString}! !!MystWindow methodsFor: 'proxy' stamp: 'PeterFisk 10/25/2017 11:40'!width: anInteger	self sendMethod: 'setWidth' args: {anInteger}! !!MystWindow methodsFor: 'proxy' stamp: 'PeterFisk 10/23/2017 15:44'!defaultProxyClass	^ 'qx.ui.window.Window'! !!MystWindow methodsFor: 'proxy' stamp: 'PeterFisk 10/25/2017 11:38'!backgroundColor: aColor	self sendMethod: 'setBackgroundColor' args: {aColor}! !!MystWindow methodsFor: 'proxy' stamp: 'PeterFisk 10/25/2017 11:40'!x: x y: y	self		sendMethod: 'moveTo'		args:			{x.			y}! !!MystWindow methodsFor: 'proxy' stamp: 'PeterFisk 10/25/2017 11:52'!show	self sendMethod: 'show'! !!MystWindow methodsFor: 'initialization' stamp: 'PeterFisk 10/23/2017 12:08'!defaultCaption	^ 'This is a window'! !!MystWindow methodsFor: 'initialization' stamp: 'PeterFisk 10/23/2017 15:33'!defaultWidth	^ 475! !!MystWindow methodsFor: 'initialization' stamp: 'PeterFisk 10/23/2017 15:34'!defaultHeight	^ 375! !!MystWindow methodsFor: 'initialization' stamp: 'PeterFisk 10/25/2017 11:41'!initialize	self create.	self caption: self defaultCaption.	self width: self defaultWidth.	self height: self defaultHeight.	self show! !MystWindow subclass: #MystHtmlWindow	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystHtmlWindow commentStamp: 'PeterFisk 10/17/2017 10:48' prior: 0!MystHtmlWindow!!MystHtmlWindow methodsFor: 'proxy' stamp: 'PeterFisk 10/26/2017 15:07'!html: aString	self sendMethod: 'setHtml' args: {aString}! !!MystHtmlWindow methodsFor: 'initialization' stamp: 'PeterFisk 10/26/2017 15:07'!defaultProxyClass	^ 'smalltalk.app.windows.HtmlWindow'! !!MystHtmlWindow methodsFor: 'initialization' stamp: 'PeterFisk 10/26/2017 15:06'!defaultCaption	^ 'This is an Html window'! !MystWindow subclass: #MystIframeWindow	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystIframeWindow commentStamp: 'PeterFisk 10/26/2017 13:53' prior: 0!MystIframeWindow!!MystIframeWindow methodsFor: 'initialization' stamp: 'PeterFisk 10/26/2017 13:54'!defaultProxyClass	^ 'smalltalk.app.windows.IframeWindow'! !!MystIframeWindow methodsFor: 'initialization' stamp: 'PeterFisk 10/26/2017 15:06'!defaultCaption	^ 'This is an Iframe window'! !!MystIframeWindow methodsFor: 'proxy' stamp: 'PeterFisk 10/26/2017 14:18'!html: aString	self sendMethod: 'setHtml' args: {aString}! !!MystIframeWindow methodsFor: 'proxy' stamp: 'PeterFisk 10/26/2017 14:23'!source: aString	self sendMethod: 'setSource' args: {aString}! !MystWindow subclass: #MystSplitWindow	instanceVariableNames: 'splitPane'	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystSplitWindow commentStamp: 'PeterFisk 10/17/2017 10:48' prior: 0!MystSplitWindow!MystWindow subclass: #MystTabbedWindow	instanceVariableNames: 'tabview'	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystTabbedWindow commentStamp: 'PeterFisk 10/17/2017 10:49' prior: 0!MystTabbedWindow!MystWindow subclass: #MystTextWindow	instanceVariableNames: 'textview'	classVariableNames: ''	poolDictionaries: ''	category: 'RailsXMyst'!!MystTextWindow commentStamp: 'PeterFisk 10/23/2017 11:51' prior: 0!MystTextWindow!!MystTextWindow methodsFor: 'initialization' stamp: 'PeterFisk 10/23/2017 11:54'!showWindow	self create.	self caption: 'THIS IS A TEXT WINDOW'.	self show! !!MystTextWindow methodsFor: 'initialization' stamp: 'PeterFisk 10/23/2017 12:13'!defaultCaption	^ 'This is a text window'! !